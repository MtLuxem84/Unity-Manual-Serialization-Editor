#if UNITY_EDITOR
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System;
using System.Reflection;
#endif

// Think at some point take a min max and add max string length. Then I won't have to touch this again.

public class MNEditor 
{

    private static string pathToCode;
    private static string FileName = "MNArrays.cs";
    private static string SerializedScriptName = "MNSerializedData.cs";
    private static int stringLength = 30;
    //private static string SerializedScriptNameTest = "MNSerializedDataTest.cs";

#if UNITY_EDITOR

    [MenuItem("MNSerializer/Create Arrays")]
    private static void CreateArrays()
    {
        RunCreateArrays();
    }

    [MenuItem("MNSerializer/Create Serialized Class")]
    private static void CreateSerializedClass()
    {
        pathToCode = Application.dataPath + "/Scripts/AutogeneratedScripts";
        MNCore.CreateSerializedClass(pathToCode, SerializedScriptName, 0);
    }

    [MenuItem("MNSerializer/Create Serialized SubClass Direct With String Max Char 30")]
    private static void CreateSerializedClassDirectWithString()
    {
        //CreateClassAndArraysStringMaxDirectSubclassOnly();
        pathToCode = Application.dataPath + "/Scripts/AutogeneratedScripts";

        MNCore.CreateSerializedClass(pathToCode, SerializedScriptName, stringLength);
    }

    public static void RunCreateArrays()
    {
        pathToCode = Application.dataPath + "/Scripts/AutogeneratedScripts";
        Debug.Log(pathToCode);

        MonoScript[] scripts = (MonoScript[])Resources.FindObjectsOfTypeAll(typeof(MonoScript));

        List<string> arrayNames = new List<string>();
        arrayNames.Add("b2");
        arrayNames.Add("b4");
        arrayNames.Add("b8");
 
        List<int> arrayValue = new List<int>();
        arrayValue.Add(2);
        arrayValue.Add(4);
        arrayValue.Add(8);

        foreach (MonoScript m in scripts)
        {
            if (m.GetClass() != null && m.GetType() != typeof(Shader))
            {
                if (!m.GetClass().GetTypeInfo().ToString().StartsWith("Unity") && !m.GetClass().GetTypeInfo().ToString().StartsWith("TMPro") && !m.GetClass().GetTypeInfo().ToString().StartsWith("Packages")
                    && !m.GetClass().GetTypeInfo().ToString().StartsWith("Microsoft"))
                {
                    Type type = m.GetClass();
                    int totalBytes = 0;
                    var methodInfos = type.GetCustomAttributes();
                    foreach (Attribute attribute in methodInfos)
                    {
                        if (attribute.GetType() == typeof(MNAttributes))
                        {
                            Debug.Log(attribute.GetType());
                            var fieldInfo = type.GetFields();
                            for (int i = 0; i < fieldInfo.Length; i++)
                            {
                                Debug.Log(fieldInfo[i].FieldType.ToString());
                                switch (fieldInfo[i].FieldType.ToString())
                                {
                                    case "System.Int16": 
                                        totalBytes += 2;
                                        break;
                                    case "System.Int32":
                                        totalBytes += 4;

                                        break;
                                    case "System.Int64":
                                        totalBytes += 8;

                                        break;
                                    case "System.UInt16":
                                        totalBytes += 2;

                                        break;
                                    case "System.UInt32":
                                        totalBytes += 4;

                                        break;
                                    case "System.UInt64":
                                        totalBytes += 8;

                                        break;
                                    case "System.Single":
                                        totalBytes += 4;

                                        break;
                                    case "System.String":
                                  
                                        break;
                                    case "System.Decimal":
                                        totalBytes += 16;

                                        break;
                                    case "System.Byte":
                                        totalBytes += 1;

                                        break;
                                    case "System.Double":
                                        totalBytes += 8;

                                        break;
                                }
                            }
                            if (totalBytes != 0)
                            {
                                if (!arrayNames.Contains("b" + totalBytes))
                                    arrayNames.Add("b" + totalBytes);
                                if (!arrayValue.Contains(totalBytes))
                                    arrayValue.Add(totalBytes);
                            }

                        }
                    }
                    //Debug.Log(m.GetClass().GetTypeInfo().ToString());
                }
            }

        }


        string s = "// AutoGenerated: " + DateTime.Now.ToString() + Environment.NewLine + "public static class MNArrays  " + Environment.NewLine + "{" + Environment.NewLine;
        s += "// Base Class to move to another project only needs b2 b4 b8 to avoid compile errors. And empty method get array" + Environment.NewLine;

        for (int i = 0; i < arrayNames.Count; i++)
        {
            Debug.Log(arrayNames[i]);
            s += "public static byte[] " + arrayNames[i] + "  = new byte[" + arrayValue[i] + "];" + Environment.NewLine;
        }

        s += "public static byte[] GetArray(int value)" + Environment.NewLine;
        s += "{" + Environment.NewLine;
        s += "switch (value)" + Environment.NewLine;
        s += "{" + Environment.NewLine;

        for (int i = 0; i < arrayNames.Count; i++)
        {               
            //case 1:
            s += "  case " + arrayValue[i].ToString() + ":" + Environment.NewLine;
            s += "  return " + arrayNames[i] + ";" + Environment.NewLine;
        }
        s += "default: return b2;";
        s += "}" + Environment.NewLine;
        s += "}" + Environment.NewLine;

        string ending = "}";

        if (!System.IO.Directory.Exists(pathToCode))
            System.IO.Directory.CreateDirectory(pathToCode);

        s += ending;
        using (System.IO.StreamWriter sw =
            new System.IO.StreamWriter(pathToCode + "/" + FileName, false))
        {
            sw.Write(s);
        }
        AssetDatabase.Refresh();

    }

    private class ScriptProperties
    {
        public string className;
        public List<string> serializeVal = new List<string>();
        public List<string> deserializeVal = new List<string>();
        public List<int> byteCount = new List<int>();

        public List<string> fieldPublicPrivate = new List<string>();
        public List<string> fieldType = new List<string>();
        public List<string> fieldNames = new List<string>();
        public int totalBytes;
        // Has to be dynamic
        public bool hasString;
    }

    private static void AddNames(ref List<string> arrayName, int value, ref List<int> arrayValue)
    {
        if (!arrayName.Contains("b" + value.ToString()))
            arrayName.Add("b" + value.ToString());
        if (!arrayValue.Contains(value))
            arrayValue.Add(value);
    }

    private static void CreateArraysWithStringMax30()
    {
        pathToCode = Application.dataPath + "/Scripts/AutogeneratedScripts";
        //Debug.Log(pathToCode);

        MonoScript[] scripts = (MonoScript[])Resources.FindObjectsOfTypeAll(typeof(MonoScript));

        // Need 30 bytes for potential fixed string
        List<string> arrayNames = new List<string>();
        List<int> arrayValue = new List<int>();


        foreach (MonoScript m in scripts)
        {
            if (m.GetClass() != null && m.GetType() != typeof(Shader))
            {
                if (!m.GetClass().GetTypeInfo().ToString().StartsWith("Unity") && !m.GetClass().GetTypeInfo().ToString().StartsWith("TMPro") && !m.GetClass().GetTypeInfo().ToString().StartsWith("Packages")
                    && !m.GetClass().GetTypeInfo().ToString().StartsWith("Microsoft"))
                {
                    Type type = m.GetClass();
                    var methodInfos = type.GetCustomAttributes();
                    foreach (Attribute attribute in methodInfos)
                    {
                        if (attribute.GetType() == typeof(MNAttributes))
                        {
                            int totalBytes = 0;

                            //Debug.Log(attribute.GetType());
                            var fieldInfo = type.GetFields();
                            for (int i = 0; i < fieldInfo.Length; i++)
                            {
                                //Debug.Log(fieldInfo[i].FieldType.ToString());
                                switch (fieldInfo[i].FieldType.ToString())
                                {
                                    case "System.Int16":
                                        totalBytes += 2;
                                        break;
                                    case "System.Int32":
                                        totalBytes += 4;

                                        break;
                                    case "System.Int64":
                                        totalBytes += 8;

                                        break;
                                    case "System.UInt16":
                                        totalBytes += 2;

                                        break;
                                    case "System.UInt32":
                                        totalBytes += 4;

                                        break;
                                    case "System.UInt64":
                                        totalBytes += 8;

                                        break;
                                    case "System.Single":
                                        totalBytes += 4;

                                        break;
                                    case "System.String":

                                        break;
                                    case "System.Decimal":
                                        totalBytes += 16;

                                        break;
                                    case "System.Byte":
                                        totalBytes += 1;
                                        break;
                                    case "System.Byte[]":
                                        break;
                                    case "System.Double":
                                        totalBytes += 8;

                                        break;
                                }
                            }
                            
                            if (totalBytes != 0)
                            {
                                if (!arrayNames.Contains("b" + totalBytes))
                                    arrayNames.Add("b" + totalBytes);
                                if (!arrayValue.Contains(totalBytes))
                                    arrayValue.Add(totalBytes);
                                // additional bytes we will use for a max string count of 30
                                int count = 30;
                                for (int q = 0; q <= totalBytes; q++)
                                {
                                    count++;
                                    if (!arrayNames.Contains("b" + count))
                                        arrayNames.Add("b" + count);
                                    if (!arrayValue.Contains(count))
                                        arrayValue.Add(count);
                                }
                            }
                        }
                    }
                   
                    //Debug.Log(m.GetClass().GetTypeInfo().ToString());
                }
            }

        }

        // Add potential string bytes
        for (int i = 0; i < 30; i++)
        {
            AddNames(ref arrayNames, i, ref arrayValue);
        }

        string s = "// AutoGenerated:" + Environment.NewLine + "public static class MNArrays  " + Environment.NewLine + "{" + Environment.NewLine;
        s += "// Base Class to move to another project only needs b2 b4 b8 to avoid compile errors. And empty method get array" + Environment.NewLine;
        for (int i = 0; i < arrayNames.Count; i++)
        {
            //Debug.Log(arrayNames[i]);
            s += "public static byte[] " + arrayNames[i] + "  = new byte[" + arrayValue[i] + "];" + Environment.NewLine;
        }

        s += "public static byte[] GetArray(int value)" + Environment.NewLine;
        s += "{" + Environment.NewLine;
        s += "switch (value)" + Environment.NewLine;
        s += "{" + Environment.NewLine;

        for (int i = 0; i < arrayNames.Count; i++)
        {
            //case 1:
            s += "  case " + arrayValue[i].ToString() + ":" + Environment.NewLine;
            s += "  return " + arrayNames[i] + ";" + Environment.NewLine;
        }
        s += "default: return new byte[0];";
        s += "}" + Environment.NewLine;
        s += "}" + Environment.NewLine;

        string ending = "}";

        if (!System.IO.Directory.Exists(pathToCode))
            System.IO.Directory.CreateDirectory(pathToCode);

        s += ending;
        using (System.IO.StreamWriter sw =
            new System.IO.StreamWriter(pathToCode + "/" + FileName, false))
        {
            sw.Write(s);
        }
        AssetDatabase.Refresh();
        Debug.Log("Done!");

    }


#endif
}


